# kallisto

We estimated transcript-level expression with kallisto v. 0.43.1. First, for each reference genome used in our study, we extracted the reference transcript set using the RSEM<em> extract-reference-transcripts</em> utility. Next, we built a kallisto index for those transcripts, with an example for <em> D. melanogaster</em> as follows:

    kallisto index -i Drosophila_melanogaster.BDGP6.dna_sm.toplevel.transcripts.idx Drosophila_melanogaster.BDGP6.dna_sm.toplevel.transcripts.fa 

Expression was then estimated for each sample. An example, genetic command line for paired-end analysis is as follows:

    kallisto quant -i /PATH/TO/Drosophila_melanogaster.BDGP6.dna_sm.toplevel.transcripts.idx -b 100 -t 6 -o <SAMPLENAME>_quant /PATH/TO/R1.fastq /PATH/TO/R2.fastq

Where the -b flag specifies the number of bootstraps (which are required for downstream DE analysis with sleuth), and -t indicated the number of threads. For single-end inference, one must specify the mean and standard deviation of the library fragment size. In our study, we use the paired-end 2x125 reads from each sample as our "truth", and obtain library size distribution information from the kallisto output for our truth set. In doing so, we round up to the nearest 50bp, given that, normally with single-end analysis, the true library size distribution is unknown. An example single-end command line is as follows:

    kallisto quant -i /PATH/TO/Drosophila_melanogaster.BDGP6.dna_sm.toplevel.transcripts.idx --single --fragment-length=300 --sd=60 -b 100 -t 6 -o <SAMPLENAME>_quant /PATH/TO/R1.fastq

## Gene-level inference
In order to generate gene-level expression estimates from kallisto transcript-level ones, for each gene, one must sum abundances from the constituent transcripts. We do this by first creating a tab-separated file that maps transcripts to genes, with "target_id", and "GENEID" as column names. We then use the R package [tximport](https://bioconductor.org/packages/release/bioc/html/tximport.html) to perform the aggegation. A generic example R script,[SumKallistoToGeneLevelExample.Rscript](https://github.com/harvardinformatics/rnaseq_readlength_assessment/blob/master/kallisto/Rscripts/SumKallistoToGeneLevelExample.Rscript) shows how to do this.

## Calculating TPM correlations
To asess the relative performance of 2x40, 1x75 and 1x125 sequencing strategies, for each sample, we calculate Spearman rank correlations between the 2x125 gold standard and trimmed reads for 2x40, 1x75 and 1x125. Assuming one has a directory for each SRA accession analyzed, and the kallisto quant outputs are stored within those directories,one can generate tables of those correlations at the transcript and gene level using [CalculateTpmSpearmanFromKallistoQuantsTranscriptLevel.py](https://github.com/harvardinformatics/rnaseq_readlength_assessment/blob/master/kallisto/PythonScripts/CalculateTpmSpearmanFromKallistoQuantsTranscriptLevel.py) and [CalculateTpmSpearmanFromKallistoQuantsGeneLevel.py](https://github.com/harvardinformatics/rnaseq_readlength_assessment/blob/master/kallisto/PythonScripts/CalculateTpmSpearmanFromKallistoQuantsGeneLevel.py), respectively.

## Differential expression with sleuth
For our truth set 2x125 paired end reads, as well our evaluated strategies (2x40,1x75,1x125), we carried out pairwise Wald tests of differential expression, providing kallisto quant outputs to sleuth, which is designed specifically for kallisto output. Practically, for each SRA accession, we generate a sample info table, e.g. ERP017328_sampleinfo.tab, which summarized the quant output directory name, the experimental condition, and the sequencing/read configuration. We then loop over this to generate Rscripts to execute Wald tets for each pair of conditions and sequencing design.(Code for generating Rscripts not provided as will depend upon your naming conventions in prior steps). Generic example R scripts are provided as [ERP017328_2x125_Mut_vs_NC.Rscript](https://github.com/harvardinformatics/rnaseq_readlength_assessment/blob/master/kallisto/Rscripts/ERP017328_2x125_Mut_vs_NC.Rscript) and [ERP017328_2x125_Mut_vs_NC_GeneLevel.Rscript](https://github.com/harvardinformatics/rnaseq_readlength_assessment/blob/master/kallisto/Rscripts/ERP017328_2x125_Mut_vs_NC_GeneLevel.Rscript), for transcript, and gene-level analyses, respectively.  

We then calcuate differential expression test performance metrics, using 2x125 as our truth set. We do this using [CalculateMetricsFromSleuthWaldGeneTable.py](https://github.com/harvardinformatics/rnaseq_readlength_assessment/blob/master/kallisto/PythonScripts/CalculateMetricsFromSleuthWaldGeneTable.py) and [CalculateMetricsFromSleuthWaldTranscriptTable.py](https://github.com/harvardinformatics/rnaseq_readlength_assessment/blob/master/kallisto/PythonScripts/CalculateMetricsFromSleuthWaldTranscriptTable.py), which iterate over the Wald test tables generated for all the pairwise tests within an SRA accession. We can then concatenate these tables in order to facilitate visualizion of global, multi-accession patterns. Note, the arguments passed to the python <em>>glob </em> function may need to be changed,depending upon the naming convention used for fastq files.

